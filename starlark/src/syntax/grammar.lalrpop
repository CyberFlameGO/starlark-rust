// Copyright 2018 The Starlark in Rust Authors.
// Copyright (c) Facebook, Inc. and its affiliates.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use codemap::Span;
use crate::syntax::lexer;
use crate::syntax::dialect::Dialect;
use crate::syntax::ast::*;

grammar(file_span: Span, dialect: &Dialect);

#[inline]
ASTS<E>: Box<AstStmt> = <l:@L> <e:E> <r:@R>
    => e.to_ast(file_span.subspan(l, r));

#[inline]
ASTE<E>: Box<AstExpr> = <l:@L> <e:E> <r:@R>
    => e.to_ast(file_span.subspan(l, r));

#[inline]
ASTP<E>: AstParameter = <l:@L> <e:E> <r:@R>
    => e.to_ast(file_span.subspan(l, r));

#[inline]
ASTA<E>: AstArgument = <l:@L> <e:E> <r:@R>
    => e.to_ast(file_span.subspan(l, r));

#[inline]
ASTC<E>: AstClause = <l:@L> <e:E> <r:@R>
    => e.to_ast(file_span.subspan(l, r));

#[inline]
integer: AstInt = <l:@L> <e:"INTEGER"> <r:@R>
    => e.to_ast(file_span.subspan(l, r));

#[inline]
string: AstString = <l:@L> <e:"STRING"> <r:@R>
    => e.to_ast(file_span.subspan(l, r));

#[inline]
identifier: AstString = <l:@L> <e:"IDENTIFIER"> <r:@R>
    => e.to_ast(file_span.subspan(l, r));

COMMA<E>: Vec<E> =
    <v0:(<E> ",")*> <e1:E?>
        => v0.into_iter().chain(e1).collect();

pub(crate) Starlark: Box<AstStmt> = ASTS<starlark_>;
starlark_: Stmt = "\n"* <(<TopStmt> "\n"*)*>
    => Stmt::Statements(<>);

TopStmt: Box<AstStmt> = { DefStmt, SimpleStmt<BuildTopStmt> };
BuildTopStmt: Box<AstStmt> = { AssignStmt, ExprStmt, LoadStmt };

DefStmt: Box<AstStmt> = ASTS<DefStmt_> =>? Ok(dialect.check_def(<>)?);
DefStmt_: Stmt =
  "def" <identifier> "(" <COMMA<ParameterTyped>> ")" <ReturnType> ":" <Suite>
      =>? Ok(Stmt::check_def(<>)?);

ReturnType: Option<Box<AstExpr>> = {
    "->" <Test> =>? Ok(Some(dialect.check_type(<>)?)),
    => None,
}

Parameter: AstParameter = ASTP<Parameter_>;
Parameter_: Parameter = {
    <n:identifier> "=" <e:Test> => Parameter::WithDefaultValue(n, None, e),
    <identifier>            => Parameter::Normal(<>, None),
    "*" <identifier>        => Parameter::Args(<>, None),
    <l:@L> "*" <r:@R>       =>? Ok(dialect.check_keyword_only_arguments(file_span.subspan(l, r), Parameter::NoArgs)?),
    "**" <identifier>       => Parameter::KWArgs(<>, None),
};

ParameterTyped: AstParameter = ASTP<ParameterTyped_>;
ParameterTyped_: Parameter = {
    <identifier> <Type> "=" <Test> => Parameter::WithDefaultValue(<>),
    <identifier> <Type>            => Parameter::Normal(<>),
    "*" <identifier> <Type>        => Parameter::Args(<>),
    <l:@L> "*" <r:@R>              =>? Ok(dialect.check_keyword_only_arguments(file_span.subspan(l, r), Parameter::NoArgs)?),
    "**" <identifier> <Type>       => Parameter::KWArgs(<>),
};

Type: Option<Box<AstExpr>> = {
    ":" <Test> =>? Ok(Some(dialect.check_type(<>)?)),
    => None,
}

Suite: Box<AstStmt> = {
    SimpleStmt<SmallStmt>,
    "\n"+ "INDENT" <l:@L> "\n"* <v:(<Stmt> "\n"*)+> <r:@R> "DEDENT"
        => Stmt::Statements(v).to_ast(file_span.subspan(l, r))
};

Stmt: Box<AstStmt> = { DefStmt, IfStmt, ForStmt, SimpleStmt<SmallStmt> };

IfBody: Box<AstStmt> = ASTS<IfBody_>;
IfBody_: Stmt = <c:Test> ":" <s:Suite> <el:ElseStmt?> => {
    match el {
        None   => Stmt::If(c, s),
        Some(e) => Stmt::IfElse(c, s, e)
    }
};

IfStmt: Box<AstStmt> = "if" <IfBody>;
ElseStmt: Box<AstStmt> = {
    "elif" <IfBody>,
    "else" ":" <Suite>
};

ForStmt: Box<AstStmt> = ASTS<ForStmt_>;
ForStmt_: Stmt = "for" <e:ExprList> "in" <c:Test> ":" <s:Suite>
    => Stmt::For(e, c, s);

SimpleStmt<S>: Box<AstStmt> =
    <l:@L> <e:S> <v:(";" <S>)*> ";"? <r:@R> "\n" => {
        if v.is_empty() {
            e
        } else {
            Stmt::Statements(
                vec![e].into_iter().chain(v.into_iter()).collect())
                    .to_ast(file_span.subspan(l, r))
        }
    };

SmallStmt: Box<AstStmt> = {
    <l:@L> "return" <e:TestList?> <r:@R>
        => Stmt::Return(e).to_ast(file_span.subspan(l, r)),
    <@L> "break" <@R>
        => Stmt::Break.to_ast(file_span.subspan(<>)),
    <@L> "continue" <@R>
        => Stmt::Continue.to_ast(file_span.subspan(<>)),
    <@L> "pass" <@R>
        => Stmt::Pass.to_ast(file_span.subspan(<>)),
    AssignStmt,
    ExprStmt
};

AssignOp: AssignOp = {
    "=" => AssignOp::Assign,
    "+=" => AssignOp::Increment,
    "-=" => AssignOp::Decrement,
    "*=" => AssignOp::Multiplier,
    "//=" => AssignOp::FloorDivider,
    "%=" => AssignOp::Percent,
};

AssignStmt: Box<AstStmt> = ASTS<AssignStmt_>;
AssignStmt_: Stmt = <TestList> <AssignOp> <TestList>
        => Stmt::Assign(<>);

// In python ExprStmt is an AssignStmt (
// https://docs.python.org/3/reference/grammar.html). This ExprStmt is
// according to the spec provided on https://github.com/google/skylark. It
// enable parsing docstring and method calls.
ExprStmt: Box<AstStmt> = ASTS<ExprStmt_>;
ExprStmt_: Stmt = <Test> => Stmt::Expression(<>);

LoadStmt: Box<AstStmt> = ASTS<LoadStmt_> =>? Ok(dialect.check_load(<>)?);
LoadStmt_: Stmt = "load" "(" <string> <("," <LoadStmtSyms>)+> ","? ")"
    => Stmt::Load(<>, dialect.load_visibility());

LoadStmtBindingName: AstString = <identifier> "=";

LoadStmtSyms: (AstString, AstString) = <id:LoadStmtBindingName?> <n:string>
    => (id.unwrap_or(n.clone()), n);

// Expression
L<E>: Box<AstExpr> = <l:@L> <v:(<E> ",")*> <e:E> <f:","?> <r:@R>
    => {
        if f.is_some() || !v.is_empty() {
            Expr::Tuple(v.into_iter().chain(vec![e].into_iter()).collect())
                .to_ast(file_span.subspan(l, r))
        } else {
            e
        }
    };

ExprList: Box<AstExpr> = L<Expr>;

TestList: Box<AstExpr> = L<Test>;

PipedExpr: Box<AstExpr> = {
    <l:@L> <e1:ArithExpr> "|" <e2:PipedExpr> <r:@R>
      => Expr::Op(e1, BinOp::Pipe, e2).to_ast(file_span.subspan(l, r)),
    ArithExpr
};

PrimaryExpr: Box<AstExpr> = {
    <l:@L> <e:PrimaryExpr> "." <i:identifier> <r:@R>
        => Expr::Dot(e, i).to_ast(file_span.subspan(l, r)),
    <l:@L> <e:PrimaryExpr> "(" <a:COMMA<Argument>> ")" <r:@R>
        =>? Ok(Expr::check_call(e, a)?.to_ast(file_span.subspan(l, r))),
    <l:@L> <e:PrimaryExpr> "[" <i1:Test?> ":" <i2:Test?> <i3:(":" <Test?>)?> "]"
        <r:@R> => {
          Expr::Slice(e, i1, i2, i3.unwrap_or(None))
              .to_ast(file_span.subspan(l, r))
        },
    <l:@L> <e:PrimaryExpr> "[" <i:TestList> "]" <r:@R>
        => Expr::ArrayIndirection(e, i).to_ast(file_span.subspan(l, r)),
    Operand
};

OptionalSlice: Box<AstExpr> = ":" <Test>;

// Note that the order of arguments (args, named, *args, **kwargs) is enforced
// at the syntax evaluation, not by the Grammar.
Argument: AstArgument = ASTA<Argument_>;
Argument_: Argument = {
    <Test>                    => Argument::Positional(<>),
    <identifier> "=" <Test>   => Argument::Named(<>),
    "*" <Test>                => Argument::ArgsArray(<>),
    "**" <Test>               => Argument::KWArgsDict(<>)
};

Operand: Box<AstExpr> = {
    <l:@L> <i:identifier> <r:@R>
        => Expr::Identifier(i).to_ast(file_span.subspan(l, r)),
    <l:@L> <i:integer> <r:@R>
        => Expr::Literal(AstLiteral::IntLiteral(i)).to_ast(file_span.subspan(l, r)),
    <l:@L> <s:string> <r:@R>
        => Expr::Literal(AstLiteral::StringLiteral(s)).to_ast(file_span.subspan(l, r)),
    <l:@L> "[" <e:COMMA<Test>> "]" <r:@R>
        => Expr::List(e).to_ast(file_span.subspan(l, r)),
    ListComp,
    <l:@L> "{" <e:COMMA<DictEntry>> "}" <r:@R>
        => Expr::Dict(e).to_ast(file_span.subspan(l, r)),
    DictComp,
    <l:@L> "(" <e:TestList?> ")" <r:@R>
        => match e {
            Some(t) => t,
            None => Expr::Tuple(vec![]).to_ast(file_span.subspan(l, r))
        }
};

DictEntry: (Box<AstExpr>, Box<AstExpr>) = <Test> ":" <Test> => (<>);

ListComp: Box<AstExpr> = ASTE<ListComp_>;
ListComp_: Expr = "[" <Test> <CompClause> "]"
    => Expr::ListComprehension(<>);

DictComp: Box<AstExpr> = ASTE<DictComp_>;
DictComp_: Expr = "{" <k:DictEntry> <v:CompClause>"}"
    => Expr::DictComprehension(<>);

CompClause: Vec<AstClause> = <CompIter+>;
CompIter: AstClause = ASTC<CompIter_>;
CompIter_: Clause = "for" <var:ExprList> "in" <over:OrTest> <ifs:IfClause*>
    => Clause {var, over, ifs};
IfClause: Box<AstExpr> = "if" <OrTest>;

// Base expression. Priorities are taken from Python 3 grammar.
Test: Box<AstExpr> = {
    <l:@L> <e1:OrTest> "if" <t:OrTest> "else" <e2:Test> <r:@R>
        => Expr::If(t, e1, e2).to_ast(file_span.subspan(l, r)),
    OrTest,
    LambDef
};

LambDef: Box<AstExpr> = {
    <l:@L> "lambda" <p:COMMA<Parameter>> ":" <e:Test> <r:@R>
        =>? Ok(dialect.check_lambda(Expr::Lambda(p, e).to_ast(file_span.subspan(l, r)))?),
}

// Binary operators
OrTest: Box<AstExpr> = {
    <l:@L> <e1:AndTest> "or" <e2:OrTest> <r:@R>
        => Expr::Op(e1, BinOp::Or, e2).to_ast(file_span.subspan(l, r)),
    AndTest,
};

AndTest: Box<AstExpr> =  {
    <l:@L> <e1:NotTest> "and" <e2:AndTest> <r:@R>
        => Expr::Op(e1, BinOp::And, e2).to_ast(file_span.subspan(l, r)),
    NotTest,
};

NotTest: Box<AstExpr> = {
  <l:@L> "not" <e:NotTest> <r:@R>
      => Expr::Not(e).to_ast(file_span.subspan(l, r)),
  CompTest,
};

CompTest: Box<AstExpr> = {
    <l:@L> <e1:Expr> "==" <e2:CompTest> <r:@R>
        => Expr::Op(e1, BinOp::EqualsTo, e2).to_ast(file_span.subspan(l, r)),
    <l:@L> <e1:Expr> "!=" <e2:CompTest> <r:@R>
        => Expr::Op(e1, BinOp::Different, e2).to_ast(file_span.subspan(l, r)),
    <l:@L> <e1:Expr> "<" <e2:CompTest> <r:@R>
        => Expr::Op(e1, BinOp::LessThan, e2).to_ast(file_span.subspan(l, r)),
    <l:@L> <e1:Expr> ">" <e2:CompTest> <r:@R>
        => Expr::Op(e1, BinOp::GreaterThan, e2).to_ast(file_span.subspan(l, r)),
    <l:@L> <e1:Expr> "<=" <e2:CompTest> <r:@R>
        => Expr::Op(e1, BinOp::LessOrEqual, e2).to_ast(file_span.subspan(l, r)),
    <l:@L> <e1:Expr> ">=" <e2:CompTest> <r:@R>
        => Expr::Op(e1, BinOp::GreaterOrEqual, e2)
                      .to_ast(file_span.subspan(l, r)),
    <l:@L> <e1:Expr> "in" <e2:CompTest> <r:@R>
        => Expr::Op(e1, BinOp::In, e2).to_ast(file_span.subspan(l, r)),
    <l:@L> <e1:Expr> "not in" <e2:CompTest> <r:@R>
        => Expr::Op(e1, BinOp::NotIn, e2).to_ast(file_span.subspan(l, r)),
    Expr
};

Expr: Box<AstExpr> = {
    <l:@L> <e1:ArithExpr> "|" <e2:Expr> <r:@R>
        => Expr::Op(e1, BinOp::Pipe, e2).to_ast(file_span.subspan(l, r)),
    ArithExpr,
};

ArithExpr: Box<AstExpr> = {
    <l:@L> <e1:ArithExpr> "+" <e2:ProductExpr> <r:@R>
        => Expr::Op(e1, BinOp::Addition, e2).to_ast(file_span.subspan(l, r)),
    <l:@L> <e1:ArithExpr> "-" <e2:ProductExpr> <r:@R>
        => Expr::Op(e1, BinOp::Subtraction, e2).to_ast(file_span.subspan(l, r)),
    ProductExpr,
};

ProductExpr: Box<AstExpr> = {
    <l:@L> <e1:ProductExpr> "*" <e2:FactorExpr> <r:@R>
        => Expr::Op(e1, BinOp::Multiplication, e2)
            .to_ast(file_span.subspan(l, r)),
    <l:@L> <e1:ProductExpr> "%" <e2:FactorExpr> <r:@R>
        => Expr::Op(e1, BinOp::Percent, e2).to_ast(file_span.subspan(l, r)),
    <l:@L> <e1:ProductExpr> "//" <e2:FactorExpr> <r:@R>
        => Expr::Op(e1, BinOp::FloorDivision, e2).to_ast(file_span.subspan(l, r)),
    FactorExpr
};

FactorExpr: Box<AstExpr> = {
    <l:@L> "+" <e:FactorExpr> <r:@R>
        => Expr::Plus(e).to_ast(file_span.subspan(l, r)),
    <l:@L> "-" <e:FactorExpr> <r:@R>
        => Expr::Minus(e).to_ast(file_span.subspan(l, r)),
    PrimaryExpr
};

extern {
    type Location = u64;
    type Error = lexer::LexerError;

    enum lexer::Token {
      "INDENT" => lexer::Token::Indent,
      "DEDENT" => lexer::Token::Dedent,
      "\n"     => lexer::Token::Newline,
      // Keywords
      "and" => lexer::Token::And,
      "else" => lexer::Token::Else,
      "load" => lexer::Token::Load,
      "break" => lexer::Token::Break,
      "for" => lexer::Token::For,
      "not" => lexer::Token::Not,
      "not in" => lexer::Token::NotIn,
      "continue" => lexer::Token::Continue,
      "if" => lexer::Token::If,
      "or" => lexer::Token::Or,
      "def" => lexer::Token::Def,
      "in" => lexer::Token::In,
      "pass" => lexer::Token::Pass,
      "elif" => lexer::Token::Elif,
      "return" => lexer::Token::Return,
      "lambda" => lexer::Token::Lambda,
      // Symbols
      "," => lexer::Token::Comma,
      ";" => lexer::Token::Semicolon,
      ":" => lexer::Token::Colon,
      "+=" => lexer::Token::PlusEqual,
      "-=" => lexer::Token::MinusEqual,
      "*=" => lexer::Token::StarEqual,
      "//=" => lexer::Token::DoubleSlashEqual,
      "%=" => lexer::Token::PercentEqual,
      "==" => lexer::Token::DoubleEqual,
      "!=" => lexer::Token::BangEqual,
      "<=" => lexer::Token::LessEqual,
      ">=" => lexer::Token::GreaterEqual,
      "**" => lexer::Token::Doublestar,
      "->" => lexer::Token::RightArrow,
      "=" => lexer::Token::Equal,
      "<" => lexer::Token::LessThan,
      ">" => lexer::Token::GreaterThan,
      "-" => lexer::Token::Minus,
      "+" => lexer::Token::Plus,
      "*" => lexer::Token::Star,
      "%" => lexer::Token::Percent,
      "//" => lexer::Token::DoubleSlash,
      "." => lexer::Token::Dot,
      "|" => lexer::Token::Pipe,
      // Brackets
      "[" => lexer::Token::OpeningBracket,
      "{" => lexer::Token::OpeningCurlyBracket,
      "(" => lexer::Token::OpeningParenthesis,
      "]" => lexer::Token::ClosingBracket,
      "}" => lexer::Token::ClosingCurlyBracket,
      ")" => lexer::Token::ClosingParenthesis,


      "RESERVED" => lexer::Token::Reserved(<String>),
      "IDENTIFIER" => lexer::Token::Identifier(<String>),
      "INTEGER" => lexer::Token::IntegerLiteral(<i32>),
      "STRING" => lexer::Token::StringLiteral(<String>)
    }
}
